var Physics2DConfig: {
    CONTACT_SLOP: number;
    EFF_MASS_EPSILON: number;
    ILL_THRESHOLD: number;
    CLIP_EPSILON: number;
    BIAS_COEF: number;
    STATIC_BIAS_COEF: number;
    CONT_BIAS_COEF: number;
    CONT_STATIC_BIAS_COEF: number;
    BOUNCE_VELOCITY_THRESHOLD: number;
    POINT_BIAS_COEF: number;
    POINT_MAX_ERROR: number;
    POINT_MAX_ERROR_SQ: number;
    POINT_SLOP_SQ: number;
    POINT_LARGE_ERROR_SQ: number;
    POINT_LARGE_ERROR_BIAS: number;
    POINT_LARGE_ERROR_MAX: number;
    WELD_BIAS_COEF: number;
    WELD_MAX_LINEAR_ERROR: number;
    WELD_MAX_ANGULAR_ERROR: number;
    WELD_MAX_LINEAR_ERROR_SQ: number;
    WELD_LINEAR_SLOP_SQ: number;
    WELD_ANGULAR_SLOP_SQ: number;
    WELD_LARGE_ERROR_SQ: number;
    WELD_LARGE_ERROR_BIAS: number;
    WELD_LARGE_ERROR_MAX: number;
    ANGLE_BIAS_COEF: number;
    ANGLE_SLOP_SQ: number;
    DIST_BIAS_COEF: number;
    DIST_SLOP_SQ: number;
    DIST_LARGE_ERROR_SQ: number;
    DIST_LARGE_ERROR_BIAS: number;
    LINE_BIAS_COEF: number;
    LINE_SLOP_SQ: number;
    LINE_LARGE_ERROR_SQ: number;
    LINE_LARGE_ERROR_BIAS: number;
    PULLEY_BIAS_COEF: number;
    PULLEY_SLOP_SQ: number;
    PULLEY_LARGE_ERROR_SQ: number;
    PULLEY_LARGE_ERROR_BIAS: number;
    MIN_LINEAR_STATIC_SWEEP: number;
    MIN_ANGULAR_STATIC_SWEEP: number;
    MIN_LINEAR_BULLET_SWEEP: number;
    MIN_ANGULAR_BULLET_SWEEP: number;
    SWEEP_LIMIT: number;
    SWEEP_SLOP: number;
    MINIMUM_SWEEP_ADVANCE: number;
    MAX_SWEEP_ITER: number;
    EQUAL_SQ_VEL: number;
    ZERO_ANG_BIAS: number;
    TOI_SLIP_SCALE: number;
    DELAYED_DEATH: number;
    DELTA_ROTATION_EPSILON: number;
    SLEEP_DELAY: number;
    SLEEP_LINEAR_SQ: number;
    SLEEP_ANGULAR_SQ: number;
    CONTAINS_EPSILON: number;
    CONTAINS_SQ_EPSILON: number;
    COLLINEAR_EPSILON: number;
    COLLINEAR_SQ_EPSILON: number;
    NORMALIZE_EPSILON: number;
    NORMALIZE_SQ_EPSILON: number;
    STATIC_FRIC_SQ_EPSILON: number;
};
class Physics2DMaterial {
    static version: number;
    public _data: any;
    public userData: any;
    static defaultMaterial: Physics2DMaterial;
    public getElasticity();
    public getStaticFriction();
    public getDynamicFriction();
    public getRollingFriction();
    public getDensity();
    static create(params?): Physics2DMaterial;
}
interface Physics2DCallbackFn {
    (thisShape: Physics2DShape, otherShape: Physics2DShape): void;
}
class Physics2DConstraint {
    public _removeOnBreak: bool;
    public _breakUnderError: bool;
    public _breakUnderForce: bool;
    public _stiff: bool;
    public _ignoreInteractions: bool;
    public sleeping: bool;
    public _active: bool;
    public _data: any;
    public world: any;
    public _islandRoot: Physics2DRigidBody;
    public _islandRank: number;
    public _island: Physics2DIsland;
    public _wakeTime: number;
    public _woken: bool;
    public _onBreak: Physics2DCallback[];
    public _onWake: Physics2DCallback[];
    public _onSleep: Physics2DCallback[];
    public _equal: bool;
    public bodyA: Physics2DRigidBody;
    public bodyB: Physics2DRigidBody;
    public _ANCHOR_A: number;
    public _ANCHOR_B: number;
    public _JACC: number;
    public userData: any;
    public _inWorld(): void;
    public _outWorld(): void;
    public _pairExists(b1: Physics2DRigidBody, b2: Physics2DRigidBody): bool;
    public _wakeConnected(): void;
    public _sleepComputation(union: (body: Physics2DRigidBody, constraint: Physics2DConstraint) => void): void;
    public _preStep(deltaTime: number): bool;
    public _warmStart(): void;
    public _iterateVel(): bool;
    public _iteratePos(): bool;
    public _draw: (debug: any) => void;
    public init(con, params): void;
    public configure(params): void;
    public addEventListener(eventType, callback): bool;
    public removeEventListener(eventType, callback): bool;
    public wake(automated?: bool): void;
    public sleep(): void;
    public isEnabled(): bool;
    public isDisabled(): bool;
    public enable(): void;
    public disable(): void;
    public getAnchorA(dst);
    public getAnchorB(dst);
    public setAnchorA(anchor): void;
    public setAnchorB(anchor): void;
    public rotateAnchor(data, body, LOCAL, RELATIVE): void;
    public dtRatio(data, deltaTime): number;
    public twoBodyInWorld(): void;
    public twoBodyOutWorld(): void;
    public twoBodyPairExists(b1, b2): bool;
    public twoBodyWakeConnected(): void;
    public twoBodySleepComputation(union): void;
    public clearCache(): void;
    public clearCache2(): void;
    public clearCache3(): void;
    public soft_params(data, KMASS, GAMMA, BIAS, deltaTime, breakUnderError): bool;
    public soft_params2(data, KMASS, GAMMA, BIAS, deltaTime, breakUnderError): bool;
    public soft_params3(data, KMASS, GAMMA, BIAS, deltaTime, breakUnderError): bool;
    public safe_solve(data, KMASS, ERR, IMP): void;
    public safe_solve2(data, KMASS, ERR, IMP): void;
    public safe_solve3(data, KMASS, ERR, IMP): void;
    public safe_invert(data, KMASS, JACC): void;
    public safe_invert2(data, KMASS, JACC): void;
    public safe_invert3(data, KMASS, JACC): void;
}
class Physics2DCustomConstraint extends Physics2DConstraint {
    public type: string;
    public wake: (automated?: bool) => void;
    public sleep: () => void;
    public configure: (params: any) => void;
    public isEnabled: () => bool;
    public isDisabled: () => bool;
    public enable: () => void;
    public disable: () => void;
    public addEventListener: (eventType: any, callback: any) => bool;
    public removeEventListener: (eventType: any, callback: any) => bool;
    public _removeOnBreak: bool;
    public _breakUnderError: bool;
    public _breakUnderForce: bool;
    public _stiff: bool;
    public _ignoreInteractions: bool;
    public sleeping: bool;
    public _active: bool;
    public world: any;
    public _islandRoot: Physics2DRigidBody;
    public _islandRank: number;
    public _island: Physics2DIsland;
    public _wakeTime: number;
    public _onBreak: Physics2DCallback[];
    public _onWake: Physics2DCallback[];
    public _onSleep: Physics2DCallback[];
    public userData: any;
    public bodies: any[];
    public _data: any;
    public dimension: number;
    public _K_MASS: number;
    public _K_CHOLESKY: number;
    public _BIAS: number;
    public _J_ACC: number;
    public _VECTOR: number;
    public _JACOBIAN: number;
    public _VECTOR_TMP: number;
    public _posConsts: () => void;
    public _posError: (data: any, index: any) => void;
    public _velError: (data: any, index: any) => void;
    public _posClamp: (data: any, index: any) => void;
    public _velClamp: (data: any, index: any) => void;
    public _jacobian: (data: any, index: any) => void;
    public _velocityOnly: bool;
    public _inWorld(): void;
    public _outWorld(): void;
    public _pairExists(b1, b2): bool;
    public _wakeConnected(): void;
    public _sleepComputation(union): void;
    public _clearCache(): void;
    public _cholesky(): void;
    public _transform(X): void;
    public _effMass(): void;
    public _preStep(deltaTime): bool;
    public _warmStart(): void;
    public getImpulseForBody(body, dst);
    public _applyImpulse(J, position?): void;
    public _iterateVel(): bool;
    public _iteratePos(): bool;
    static create(params): Physics2DCustomConstraint;
}
class Physics2DPulleyConstraint extends Physics2DConstraint {
    public type: string;
    public wake: (automated?: bool) => void;
    public sleep: () => void;
    public configure: (params: any) => void;
    public isEnabled: () => bool;
    public isDisabled: () => bool;
    public enable: () => void;
    public disable: () => void;
    public addEventListener: (eventType: any, callback: any) => bool;
    public removeEventListener: (eventType: any, callback: any) => bool;
    public _drawLink: (debug: any, x1: any, y1: any, x2: any, y2: any, nx: any, ny: any, nl: any, bias: any, scale: any, colSA: any, colSB: any) => void;
    public dimension: number;
    public bodyC: Physics2DRigidBody;
    public bodyD: Physics2DRigidBody;
    public _slack: bool;
    public getRatio();
    public setRatio(ratio): void;
    public getLowerBound();
    public getUpperBound();
    public setLowerBound(lowerBound): void;
    public setUpperBound(upperBound): void;
    public _ANCHOR_A: number;
    public getAnchorA: (dst: any) => any;
    public setAnchorA: (anchor: any) => void;
    public _ANCHOR_B: number;
    public getAnchorB: (dst: any) => any;
    public setAnchorB: (anchor: any) => void;
    public _ANCHOR_C: number;
    public getAnchorC(dst);
    public setAnchorC(anchor): void;
    public _ANCHOR_D: number;
    public getAnchorD(dst);
    public setAnchorD(anchor): void;
    public _inWorld(): void;
    public _outWorld(): void;
    public _pairExists(b1, b2): bool;
    public _wakeConnected(): void;
    public _sleepComputation(union): void;
    public _JACC: number;
    public _clearCache: () => void;
    public _posError(): void;
    public _preStep(deltaTime): bool;
    public _warmStart(): bool;
    public getImpulseForBody(body, dst);
    public _iterateVel(): bool;
    public _iteratePos(): bool;
    static create(params): Physics2DPulleyConstraint;
}
class Physics2DMotorConstraint extends Physics2DConstraint {
    public type: string;
    public wake: (automated?: bool) => void;
    public sleep: () => void;
    public configure: (params: any) => void;
    public isEnabled: () => bool;
    public isDisabled: () => bool;
    public enable: () => void;
    public disable: () => void;
    public addEventListener: (eventType: any, callback: any) => bool;
    public removeEventListener: (eventType: any, callback: any) => bool;
    public dimension: number;
    public getRate();
    public getRatio();
    public setRate(rate): void;
    public setRatio(ratio): void;
    public _inWorld: () => void;
    public _outWorld: () => void;
    public _pairExists: (b1: any, b2: any) => bool;
    public _wakeConnected: () => void;
    public _sleepComputation: (union: any) => void;
    public _JACC: number;
    public _clearCache: () => void;
    public _preStep(deltaTime): bool;
    public _warmStart(): void;
    public getImpulseForBody(body, dst);
    public _iterateVel(): bool;
    public _iteratePos(): bool;
    static create(params): Physics2DMotorConstraint;
}
class Physics2DLineConstraint extends Physics2DConstraint {
    public type: string;
    public wake: (automated?: bool) => void;
    public sleep: () => void;
    public configure: (params: any) => void;
    public isEnabled: () => bool;
    public isDisabled: () => bool;
    public enable: () => void;
    public disable: () => void;
    public addEventListener: (eventType: any, callback: any) => bool;
    public removeEventListener: (eventType: any, callback: any) => bool;
    public dimension: number;
    public getLowerBound();
    public getUpperBound();
    public setLowerBound(lowerBound): void;
    public setUpperBound(upperBound): void;
    public _ANCHOR_A: number;
    public getAnchorA: (dst: any) => any;
    public setAnchorA: (anchor: any) => void;
    public _ANCHOR_B: number;
    public getAnchorB: (dst: any) => any;
    public setAnchorB: (anchor: any) => void;
    public getAxis(dst);
    public setAxis(axis): void;
    public _inWorld: () => void;
    public _outWorld: () => void;
    public _pairExists: (b1: any, b2: any) => bool;
    public _wakeConnected: () => void;
    public _sleepComputation: (union: any) => void;
    public _JACC: number;
    public _clearCache: () => void;
    public _posError(): void;
    public _preStep(deltaTime): bool;
    public _warmStart(): void;
    public getImpulseForBody(body, dst);
    public _iterateVel(): bool;
    public _iteratePos(): bool;
    static create(params): Physics2DLineConstraint;
}
class Physics2DDistanceConstraint extends Physics2DConstraint {
    public type: string;
    public wake: (automated?: bool) => void;
    public sleep: () => void;
    public configure: (params: any) => void;
    public isEnabled: () => bool;
    public isDisabled: () => bool;
    public enable: () => void;
    public disable: () => void;
    public addEventListener: (eventType: any, callback: any) => bool;
    public removeEventListener: (eventType: any, callback: any) => bool;
    public dimension: number;
    public _slack: bool;
    public getLowerBound();
    public getUpperBound();
    public setLowerBound(lowerBound): void;
    public setUpperBound(upperBound): void;
    public _ANCHOR_A: number;
    public getAnchorA: (dst: any) => any;
    public setAnchorA: (anchor: any) => void;
    public _ANCHOR_B: number;
    public getAnchorB: (dst: any) => any;
    public setAnchorB: (anchor: any) => void;
    public _inWorld: () => void;
    public _outWorld: () => void;
    public _pairExists: (b1: any, b2: any) => bool;
    public _wakeConnected: () => void;
    public _sleepComputation: (union: any) => void;
    public _JACC: number;
    public _clearCache: () => void;
    public _posError(): void;
    public _preStep(deltaTime): bool;
    public _warmStart(): bool;
    public getImpulseForBody(body, dst);
    public _iterateVel(): bool;
    public _iteratePos(): bool;
    static create(params): Physics2DDistanceConstraint;
}
class Physics2DAngleConstraint extends Physics2DConstraint {
    public type: string;
    public wake: (automated?: bool) => void;
    public sleep: () => void;
    public configure: (params: any) => void;
    public isEnabled: () => bool;
    public isDisabled: () => bool;
    public enable: () => void;
    public disable: () => void;
    public addEventListener: (eventType: any, callback: any) => bool;
    public removeEventListener: (eventType: any, callback: any) => bool;
    public _drawForBody: (debug: any, x1: any, y1: any, x2: any, y2: any, nx: any, nl: any, bias: any, scale: any, colSA: any, colSB: any) => void;
    public dimension: number;
    public _slack: bool;
    public getLowerBound();
    public getUpperBound();
    public getRatio();
    public setLowerBound(lowerBound): void;
    public setUpperBound(upperBound): void;
    public setRatio(ratio): void;
    public _inWorld: () => void;
    public _outWorld: () => void;
    public _pairExists: (b1: any, b2: any) => bool;
    public _wakeConnected: () => void;
    public _sleepComputation: (union: any) => void;
    public _JACC: number;
    public _clearCache: () => void;
    public _posError(): void;
    public _preStep(deltaTime): bool;
    public _warmStart(): bool;
    public getImpulseForBody(body, dst);
    public _iterateVel(): bool;
    public _iteratePos(): bool;
    static create(params): Physics2DAngleConstraint;
}
class Physics2DWeldConstraint extends Physics2DConstraint {
    public type: string;
    public wake: (automated?: bool) => void;
    public sleep: () => void;
    public configure: (params: any) => void;
    public isEnabled: () => bool;
    public isDisabled: () => bool;
    public enable: () => void;
    public disable: () => void;
    public addEventListener: (eventType: any, callback: any) => bool;
    public removeEventListener: (eventType: any, callback: any) => bool;
    public dimension: number;
    public _slack: bool;
    public _ANCHOR_A: number;
    public getAnchorA: (dst: any) => any;
    public setAnchorA: (anchor: any) => void;
    public _ANCHOR_B: number;
    public getAnchorB: (dst: any) => any;
    public setAnchorB: (anchor: any) => void;
    public getPhase();
    public setPhase(phase): void;
    public _inWorld: () => void;
    public _outWorld: () => void;
    public _pairExists: (b1: any, b2: any) => bool;
    public _wakeConnected: () => void;
    public _sleepComputation: (union: any) => void;
    public _JACC: number;
    public _clearCache: () => void;
    public _preStep(deltaTime): bool;
    public _warmStart(): void;
    public getImpulseForBody(body, dst);
    public _iterateVel(): bool;
    public _iteratePos(): bool;
    static create(params): Physics2DWeldConstraint;
}
class Physics2DPointConstraint extends Physics2DConstraint {
    public type: string;
    public wake: (automated?: bool) => void;
    public sleep: () => void;
    public configure: (params: any) => void;
    public isEnabled: () => bool;
    public isDisabled: () => bool;
    public enable: () => void;
    public disable: () => void;
    public addEventListener: (eventType: any, callback: any) => bool;
    public removeEventListener: (eventType: any, callback: any) => bool;
    public dimension: number;
    public _ANCHOR_A: number;
    public getAnchorA: (dst: any) => any;
    public setAnchorA: (anchor: any) => void;
    public _ANCHOR_B: number;
    public getAnchorB: (dst: any) => any;
    public setAnchorB: (anchor: any) => void;
    public _inWorld: () => void;
    public _outWorld: () => void;
    public _pairExists: (b1: any, b2: any) => bool;
    public _wakeConnected: () => void;
    public _sleepComputation: (union: any) => void;
    public _JACC: number;
    public _clearCache: () => void;
    public _preStep(deltaTime): bool;
    public _warmStart(): void;
    public getImpulseForBody(body, dst);
    public _iterateVel(): bool;
    public _iteratePos(): bool;
    static create(params): Physics2DPointConstraint;
}
class Physics2DShape {
    static uniqueId: number;
    public body: Physics2DRigidBody;
    public type: string;
    public sensor: bool;
    public arbiters: Physics2DArbiter[];
    public userData: any;
    public id: number;
    public _bphaseHandle: Physics2DBoxTreeBroadphaseHandle;
    public _onPreSolve: Physics2DCallback[];
    public _events: Physics2DCallback[];
    public _material: Physics2DMaterial;
    public _group: number;
    public _type: number;
    public _mask: number;
    public _data: any;
    public computeArea(): number;
    public computeMasslessInertia(): number;
    public computeCenterOfMass: (dst?: any) => any;
    public translate(translation, skip: bool): void;
    public _update(posX: number, posY: number, cos: number, sin: number, skipAABB?: bool): void;
    public clone(): Physics2DShape;
    public getGroup(): number;
    public setGroup(group): void;
    public getMask(): number;
    public setMask(mask): void;
    public getMaterial(): Physics2DMaterial;
    public setMaterial(material): void;
    public copyCommon(from, to): void;
    public init(shape, params): void;
    public eventIndex(events, type, callback, callbackMask);
    public addEventListener(eventType, callback, callbackMask?, deterministic?): bool;
    public removeEventListener(eventType, callback, callbackMask): bool;
}
class Physics2DCircle extends Physics2DShape {
    static version: number;
    public type: string;
    public getMaterial: () => Physics2DMaterial;
    public setMaterial: (material: any) => void;
    public getGroup: () => number;
    public setGroup: (group: any) => void;
    public getMask: () => number;
    public setMask: (mask: any) => void;
    public addEventListener: (eventType: any, callback: any, callbackMask?: any, deterministic?: any) => bool;
    public removeEventListener: (eventType: any, callback: any, callbackMask: any) => bool;
    public computeArea(): number;
    public computeMasslessInertia(): number;
    public getRadius();
    public setRadius(radius): void;
    public getOrigin(dst?);
    public setOrigin(origin): void;
    public clone(): Physics2DCircle;
    public scale(scale: number): void;
    public translate(translation, skip): void;
    public rotate(rotation): void;
    public transform(matrix): void;
    public _update(posX, posY, cos, sin, skipAABB?): void;
    public _validate(): void;
    public computeCenterOfMass: (dst?: any) => any;
    static create(params): Physics2DCircle;
}
class Physics2DPolygon extends Physics2DShape {
    static version: number;
    public type: string;
    public getMaterial: () => Physics2DMaterial;
    public setMaterial: (material: any) => void;
    public getGroup: () => number;
    public setGroup: (group: any) => void;
    public getMask: () => number;
    public setMask: (mask: any) => void;
    public addEventListener: (eventType: any, callback: any, callbackMask?: any, deterministic?: any) => bool;
    public removeEventListener: (eventType: any, callback: any, callbackMask: any) => bool;
    public computeArea(): number;
    public computeMasslessInertia(): number;
    private _computeCenterOfMass(dst?);
    public computeCenterOfMass: (dst?: any) => any;
    public setVertices(vertices): void;
    public clone(): Physics2DPolygon;
    public scale(scaleX: number, scaleY?: number): void;
    public translate(translation, skip): void;
    public rotate(rotation): void;
    public transform(matrix): void;
    public _update(posX, posY, cos, sin, skipAABB?): void;
    public _validate(vertices): void;
    static create(params, inVertices?): Physics2DPolygon;
}
class Physics2DRigidBody {
    static version: number;
    public _data: any;
    public _type: number;
    public shapes: Physics2DShape[];
    public constraints: Physics2DConstraint[];
    public world: Physics2DWorld;
    public _customMass: bool;
    public _customInertia: bool;
    public sleeping: bool;
    public bullet: bool;
    public _sweepFrozen: bool;
    public _deferred: bool;
    public _island: Physics2DIsland;
    public _islandRank: number;
    public _islandRoot: Physics2DRigidBody;
    public _isBody: bool;
    public _wakeTime: number;
    public _woken: bool;
    public _invalidated: bool;
    public userData: any;
    public _onWake: Physics2DCallback[];
    public _onSleep: Physics2DCallback[];
    public isDynamic(): bool;
    public setAsDynamic(): void;
    public isStatic(): bool;
    public setAsStatic(): void;
    public isKinematic(): bool;
    public setAsKinematic(): void;
    public _setTypeValue(newType): void;
    public applyImpulse(impulse, position?): void;
    public setVelocityFromPosition(newPosition, newRotation, deltaTime): void;
    public transformWorldPointToLocal(src, dst);
    public transformWorldVectorToLocal(src, dst);
    public transformLocalPointToWorld(src, dst);
    public transformLocalVectorToWorld(src, dst);
    public getPosition(dst);
    public setPosition(position): void;
    public getRotation();
    public setRotation(rotation): void;
    public getVelocity(dst);
    public setVelocity(velocity): void;
    public getAngularVelocity();
    public setAngularVelocity(angularVelocity): void;
    public getForce(dst);
    public setForce(force): void;
    public getTorque();
    public setTorque(torque): void;
    public getSurfaceVelocity(dst);
    public setSurfaceVelocity(surfaceVelocity): void;
    public getMass();
    public getInertia();
    public setMass(mass): void;
    public setMassFromShapes(): void;
    public setInertia(inertia): void;
    public setInertiaFromShapes(): void;
    public _invalidateMassInertia(): void;
    public getLinearDrag(): number;
    public setLinearDrag(linearDrag): void;
    public getAngularDrag(): number;
    public setAngularDrag(angularDrag): void;
    public addShape(shape): bool;
    public removeShape(shape): bool;
    public computeMassFromShapes(): number;
    public computeInertiaFromShapes(): number;
    public wake(automated?: bool): void;
    public sleep(): void;
    public computeLocalCenterOfMass(dst?);
    public computeWorldBounds(dst);
    public alignWithOrigin(): void;
    public _invalidate(): void;
    public _update(): void;
    public _atRest(deltaTime, timeStamp): bool;
    public _deltaRotation(delta);
    public _sweepIntegrate(deltaTime): void;
    public integrate(deltaTime): void;
    public addEventListener(eventType, callback): bool;
    public removeEventListener(eventType, callback): bool;
    static create(params): Physics2DRigidBody;
}
interface Physics2DCallback {
    thisObject: any;
    callback: Physics2DCallbackFn;
    time: number;
    index: number;
    arbiter: Physics2DArbiter;
    next: Physics2DCallback;
}
function Physics2DCallback();
class Physics2DIsland {
    public components: any[];
    public sleeping: bool;
    public wakeTime: number;
    public next: Physics2DIsland;
    constructor();
    static pool: Physics2DIsland;
    static allocate(): Physics2DIsland;
    static deallocate(island): void;
}
interface Physics2DTOIEvent {
    next: Physics2DTOIEvent;
    shapeA: Physics2DShape;
    shapeB: Physics2DShape;
    frozenA: bool;
    frozenB: bool;
    arbiter: Physics2DArbiter;
    failed: bool;
    slipped: bool;
    staticType: bool;
    kinematic: bool;
    _data: any;
}
function Physics2DTOIEvent();
class Physics2DBoxTreeBroadphaseHandle {
    public boxTreeIndex: number;
    public data: any;
    public isStatic: bool;
    constructor();
    static pool: Physics2DBoxTreeBroadphaseHandle[];
    static allocate();
    static deallocate(handle: Physics2DBoxTreeBroadphaseHandle): void;
}
class Physics2DBoxTreeBroadphase {
    static version: number;
    public staticTree: BoxTree;
    public dynamicTree: BoxTree;
    public overlappingNodes: any[];
    constructor();
    public sample(box, lambda, thisObject): void;
    public insert(data, box, isStatic);
    public update(handle, box, isStatic?: bool): void;
    public remove(handle): void;
    public clear(callback, thisObject): void;
    public _clearTree(tree, callback, thisObject): void;
    public _validate(): void;
    public perform(lambda, thisObject): void;
    static create(): Physics2DBoxTreeBroadphase;
}
class Physics2DSweepAndPruneHandle {
    public _next: Physics2DSweepAndPruneHandle;
    public _prev: Physics2DSweepAndPruneHandle;
    public _aabb: any;
    public data: any;
    public isStatic: bool;
    constructor();
    static pool: Physics2DSweepAndPruneHandle;
    static allocate(): Physics2DSweepAndPruneHandle;
    static deallocate(handle): void;
}
class Physics2DSweepAndPrune {
    static version: number;
    public _list: Physics2DSweepAndPruneHandle;
    public sample(rectangle, lambda, thisObject): void;
    public insert(data, aabb, isStatic): Physics2DSweepAndPruneHandle;
    public update(handle, aabb, isStatic): void;
    public remove(handle): void;
    public clear(callback, thisObject): void;
    public _validate(): void;
    public perform(lambda, thisObject): void;
    static create(): Physics2DSweepAndPrune;
}
interface Physics2DContact {
    _data: any;
    fresh: bool;
    _hash: number;
    _timeStamp: number;
    _next: Physics2DContact;
    active: bool;
    virtual: bool;
}
function Physics2DContact();
class Physics2DArbiter {
    public shapeA: Physics2DShape;
    public shapeB: Physics2DShape;
    public bodyA: Physics2DRigidBody;
    public bodyB: Physics2DRigidBody;
    public sensor: bool;
    public _next: Physics2DArbiter;
    public _retired: bool;
    public _reverse: bool;
    public _lazyRetired: bool;
    public _static: bool;
    public _state: number;
    public _createStamp: number;
    public _updateStamp: number;
    public _sleepStamp: number;
    public _timeStamp: number;
    public _createContinuous: bool;
    public _endGenerated: number;
    public _midStep: bool;
    public sleeping: bool;
    public active: bool;
    public _invalidated: bool;
    public _data: any;
    public contacts: Physics2DContact[];
    public _userdef: number;
    public _velocity2Contact: bool;
    public _position2Contact: bool;
    public _contact1: Physics2DContact;
    public _contact2: Physics2DContact;
    public _faceType: number;
    constructor();
    static version: number;
    public getNormal(dst): Physics2DContact;
    public getRollingImpulse(): number;
    public getElasticity(): Physics2DContact;
    public getDynamicFriction(): Physics2DContact;
    public getStaticFriction(): Physics2DContact;
    public getRollingFriction(): Physics2DContact;
    public setElasticity(elasticity): void;
    public setDynamicFriction(dynamicFriction): void;
    public setStaticFriction(staticFriction): void;
    public setRollingFriction(rollingFriction): void;
    public setElasticityFromShapes(): void;
    public setDynamicFrictionFromShapes(): void;
    public setStaticFrictionFromShapes(): void;
    public setRollingFrictionFromShapes(): void;
    public isStateAccepted(): bool;
    public isStatePersistent(): bool;
    public setAcceptedState(accepted): void;
    public setPersistentState(persistent): void;
    public _lazyRetire(ignoreShape): void;
    public _assign(s1, s2): void;
    public _retire(): void;
    public _invalidate(dontSkip?: bool): void;
    public _validate(): void;
    public _injectContact(px, py, nx, ny, dist, hash, virtual): Physics2DContact;
    public _cleanContacts(timeStamp): bool;
    public _preStep(deltaTime, timeStamp, continuous): bool;
    public _iterateVelocity(): void;
    public _refreshContactData(): void;
    public _iteratePosition(): void;
    public _warmStart(): void;
    public getImpulseForBody(body, dst): Physics2DContact;
    static pool: Physics2DArbiter;
    static allocate(): Physics2DArbiter;
    static deallocate(arb): void;
}
interface Physics2DSampler {
    store: Physics2DShape[];
    count: number;
    collisions: Physics2DCollisionUtils;
    sample(handle, bounds): void;
    rectangleShape?: Physics2DShape;
    circleShape?: Physics2DShape;
}
interface Physics2DRay {
    origin: any;
    direction: any;
    maxFactor: number;
}
interface Physics2DCastCallback {
    (userThis: any, ray: Physics2DRay, result: Physics2DCastResult): bool;
}
interface Physics2DRayCast {
    minNormal: any;
    minShape: Physics2DShape;
    minFactor: number;
    userCallback: Physics2DCastCallback;
    userThis: any;
    ray: Physics2DRay;
    noInner: bool;
    normal: any;
    sample(handle): void;
}
interface Physics2DCastResult {
    shape: Physics2DShape;
    hitNormal: any;
    hitPoint: any;
    factor: number;
}
interface Physics2DConvexCast {
    toi: Physics2DTOIEvent;
    minData: any;
    minShape: Physics2DShape;
    minTOIAlpha: number;
    userCallback: Physics2DCastCallback;
    userThis: any;
    deltaTime: number;
    sample(handle): void;
}
class Physics2DWorld {
    static version: number;
    public simulatedTime: number;
    public rigidBodies: Physics2DRigidBody[];
    public constraints: Physics2DConstraint[];
    public liveDynamics: Physics2DRigidBody[];
    public liveKinematics: Physics2DRigidBody[];
    public liveConstraints: Physics2DConstraint[];
    public dynamicArbiters: Physics2DArbiter[];
    public staticArbiters: Physics2DArbiter[];
    public timeStamp: number;
    public broadphase: Physics2DBoxTreeBroadphase;
    public velocityIterations: number;
    public positionIterations: number;
    public _islands: Physics2DIsland[];
    public _toiEvents: Physics2DTOIEvent[];
    public _deferredWake: Physics2DRigidBody[];
    public _eventTime: number;
    public _callbacks: Physics2DCallback[];
    public _midStep: bool;
    public _deltaTime: number;
    public _gravityX: number;
    public _gravityY: number;
    public _collisions: Physics2DCollisionUtils;
    public _sampleRectangle: any;
    public _shapePointCallback: Physics2DSampler;
    public _bodyPointCallback: Physics2DSampler;
    public _shapeRectangleCallback: Physics2DSampler;
    public _bodyRectangleCallback: Physics2DSampler;
    public _rectangleQueryVertices: any[];
    public _rectangleQueryShape: Physics2DPolygon;
    public _shapeCircleCallback: Physics2DSampler;
    public _bodyCircleCallback: Physics2DSampler;
    public _circleQueryShape: Physics2DCircle;
    public _rayCast: Physics2DRayCast;
    public _convexCast: Physics2DConvexCast;
    public getGravity(dst?): any;
    public setGravity(gravity): void;
    public _addShape(shape): void;
    public _removeShape(shape, noCallbacks?: bool): void;
    public _enabledConstraint(constraint): void;
    public _disabledConstraint(constraint): void;
    public addConstraint(constraint): bool;
    public removeConstraint(constraint): bool;
    public addRigidBody(body): bool;
    public removeRigidBody(body, noCallbacks?: bool): bool;
    public clear(): void;
    public _clearArbiters(arbiters): void;
    public shapePointQuery(point, store): number;
    public bodyPointQuery(point, store): number;
    public _pointQuery(callback, point, store): number;
    public shapeCircleQuery(center, radius, store): number;
    public bodyCircleQuery(center, radius, store): number;
    public _circleQuery(callback, center, radius, store): number;
    public shapeRectangleQuery(point, store): Physics2DContact;
    public bodyRectangleQuery(point, store): Physics2DContact;
    public _rectangleQuery(callback, aabb, store);
    public rayCast(ray: Physics2DRay, noInnerSurfaces, customCallback, thisObject): Physics2DCastResult;
    public convexCast(shape, deltaTime, customCallback, thisObject): Physics2DCastResult;
    public step(deltaTime): void;
    public _discreteCollisions(): void;
    public _doDeferredWake(continuous): void;
    public _collisionType(s1, s2, b1, b2): bool;
    public _discreteNarrowPhase(handleA, handleB, continuous);
    public _continuousCollisions(deltaTime): void;
    public _continuousNarrowPhase(handleA, handleB): void;
    public __union(x, y): void;
    public __find(x);
    public _sleepComputations(deltaTime): void;
    public _sortArbiters(): void;
    public _subSortArbiters(arbiters): void;
    public _onWakeCallbacks(component): void;
    public _pushCallbacks(thisObject, callbacks): void;
    public _pushInteractionEvents(eventType, arb): void;
    public _brokenConstraint(con): void;
    public _preStep(deltaTime): void;
    public _preStepArbiter(arb, deltaTime, progressEvents?: bool): void;
    public _preStepArbiters(arbiters, deltaTime): void;
    public _iterateVelocity(count): void;
    public _iterateVelocityArbiters(arbiters): void;
    public _iteratePosition(count): void;
    public _iteratePositionArbiters(arbiters): void;
    public _integrateVelocity(deltaTime): void;
    public _integratePosition(deltaTime): void;
    public _integratePositionBodies(bodies, deltaTime): void;
    public _finalize(): void;
    public _finalizeArbiters(arbiters): void;
    public _finalizeBodies(bodies): void;
    public _doCallbacks(): void;
    public _warmStart(): void;
    public _warmStartArbiters(arbiters): void;
    public _forceSleepBody(body): void;
    public _forceSleepConstraint(constraint): void;
    public _wakeConstraint(constraint, noCallback?): void;
    public _wakeBody(body, noCallback?, continuousCallbacks?): void;
    public _wakeArbiter(arb, continuousCallbacks?: bool): void;
    public _continuousArbiterPrepare(arb, deltaTime, progressEvents?: bool): void;
    public _wakeArbiters(arbiters, skip, continuousCallbacks): void;
    public _wakeIsland(island, noCallbackObject, continuousCallbacks?): void;
    public _transmitBodyType(body, newType): void;
    public _validate(): void;
    public _validateBodies(bodies): void;
    static create(params): Physics2DWorld;
}
class Physics2DCollisionUtils {
    public _toi: Physics2DTOIEvent;
    public containsPoint(shape, point): bool;
    public signedDistance(shapeA, shapeB, witnessA, witnessB, axis): number;
    public intersects(shapeA, shapeB): bool;
    public rayTest(shape, ray, normal, ignoreInnerSurfaces): number;
    public sweepTest(shapeA, shapeB, deltaTime, point, normal): number;
    public _rayTest(shape, ray, normal, noInner);
    public _rayTestPolygon(poly, ray, normal, noInner);
    public _rayTestCircle(circle, ray, normal, noInner): number;
    public _contains(shape, x, y): bool;
    public _containsCircle(circle, x, y): bool;
    public _containsPolygon(poly, x, y): bool;
    public _dynamicSweep(toi: Physics2DTOIEvent, timeStep: number, negRadius: number, slowSweep?: bool): number;
    public _staticSweep(toi: Physics2DTOIEvent, timeStep: number, negRadius?): number;
    public _distance(shapeA, shapeB, toiData): number;
    public _distanceCircle2Circle(circleA, circleB, toiData): number;
    public _distanceCircle2Polygon(circle, polygon, toiData): number;
    public _distancePolygon2Polygon(polyA, polyB, toiData): number;
    public _collide(shapeA, shapeB, arb): bool;
    public _collideCircle2Polygon(circle, polygon, arb, reverse): bool;
    public _collidePolygon2Polygon(polyA, polyB, arb): bool;
    public _collideCircle2Circle(circleA, circleB, arb): bool;
    public _test(shapeA, shapeB): bool;
    public _testCircle2Circle(circleA, circleB): bool;
    public _testCircle2Polygon(circle, polygon): bool;
    public _testPolygon2Polygon(polyA, polyB): bool;
    static create(): Physics2DCollisionUtils;
}
class Physics2DDevice {
    static version: number;
    public vendor: string;
    public floatArray: any;
    public uint16Array: any;
    public getDefaultMaterial(): Physics2DMaterial;
    public createCircleShape(params): Physics2DCircle;
    public createPolygonShape(params): Physics2DPolygon;
    public createRigidBody(params): Physics2DRigidBody;
    public createWorld(params): Physics2DWorld;
    public createMaterial(params): Physics2DMaterial;
    public createSweepAndPruneBroadphase(): Physics2DSweepAndPrune;
    public createBoxTreeBroadphase(): Physics2DBoxTreeBroadphase;
    public createCollisionUtils(): Physics2DCollisionUtils;
    public createPointConstraint(params): Physics2DPointConstraint;
    public createWeldConstraint(params): Physics2DWeldConstraint;
    public createAngleConstraint(params): Physics2DAngleConstraint;
    public createDistanceConstraint(params): Physics2DDistanceConstraint;
    public createLineConstraint(params): Physics2DLineConstraint;
    public createMotorConstraint(params): Physics2DMotorConstraint;
    public createPulleyConstraint(params): Physics2DPulleyConstraint;
    public createCustomConstraint(params): Physics2DCustomConstraint;
    public createRectangleVertices(minX, minY, maxX, maxY): any[];
    public createBoxVertices(width, height): any[];
    public createRegularPolygonVertices(diameterX, diameterY, numVertices): any[];
    static create(): Physics2DDevice;
}
class Physics2DDebugDraw {
    static version: number;
    private _width;
    private _height;
    private _invalidated;
    private _graphicsDevice;
    private _screenPort;
    private _screenPortEnabled;
    private _physics2DPort;
    private _physics2DPortEnabled;
    public physics2DToScreen: number;
    public screenToPhysics2D: number;
    public circleMaxError: number;
    public curveMaxError: number;
    public spiralMaxArc: number;
    public spiralEpsilon: number;
    public spiralSpringSize: number;
    private _curveStack;
    private _curveVerts;
    public minSpringLength: number;
    public showConstraints: bool;
    public constraintAnchorRadius: number;
    public constraintSpringRadius: number;
    public constraintSpringNumCoils: number;
    public constraintSpiralMinRadius: number;
    public constraintSpiralDeltaRadius: number;
    public constraintSpiralNumCoils: number;
    public constraintColorA: any;
    public constraintSleepingColorA: any;
    public constraintColorB: any;
    public constraintSleepingColorB: any;
    public constraintColorC: any;
    public constraintSleepingColorC: any;
    public constraintColorD: any;
    public constraintSleepingColorD: any;
    public constraintErrorColorA: any;
    public constraintErrorSleepingColorA: any;
    public constraintErrorColorB: any;
    public constraintErrorSleepingColorB: any;
    public constraintErrorColorC: any;
    public constraintErrorSleepingColorC: any;
    public constraintErrorColorD: any;
    public constraintErrorSleepingColorD: any;
    public showContacts: bool;
    public showContactImpulses: bool;
    public contactRadius: number;
    public contactImpulseScale: number;
    public dynamicContactColor: any;
    public staticContactColor: any;
    public normalImpulseColor: any;
    public frictionImpulseColor: any;
    public showRigidBodies: bool;
    public showColliderShapes: bool;
    public showSensorsShapes: bool;
    public showBodyDetail: bool;
    public showShapeDetail: bool;
    public bodyPositionRadius: number;
    public circleOriginRadius: number;
    public bodyDetailColor: any;
    public shapeDetailColor: any;
    private _colors;
    private _techniqueParams;
    private _technique;
    private _vertexBufferParameters;
    private _vertexBuffer;
    private _semantics;
    private _indexBufferParameters;
    private _indexBuffer;
    private _vertexData;
    private _indexData;
    private _numVertices;
    private _numLines;
    public setPhysics2DViewport(viewport): void;
    public setScreenViewport(viewport: any): void;
    public drawLine(x1, y1, x2, y2, color): void;
    public drawLinearSpring(x1, y1, x2, y2, numCoils, radius, color): void;
    public _drawAngleIndicator(x, y, ang, rad, size, color): void;
    public _drawAnchor(x, y, rad, color): void;
    public drawSpiral(x, y, ang1, ang2, rad1, rad2, color): void;
    public drawSpiralSpring(x, y, ang1, ang2, rad1, rad2, numCoils, color): void;
    public drawCurve(x1, y1, cx, cy, x2, y2, color): void;
    public drawRectangle(x1, y1, x2, y2, color): void;
    public drawCircle(x, y, radius, color): void;
    public drawRigidBody(body): void;
    public drawConstraint(con): void;
    public drawWorld(world): void;
    public _drawArbiters(arbiters): void;
    public _drawShape(shape): void;
    public _drawCircleShape(circle, color): void;
    public _drawPolygonShape(polygon, color): void;
    public begin(): void;
    public end(): void;
    public _prepare(numVerts, numLines): void;
    public _bufferSizeAlgorithm(target): number;
    public _dispatch(): void;
    public destroy(): void;
    static create(params): Physics2DDebugDraw;
}
interface BoxTreeRay {
    origin: any;
    direction: any;
    maxFactor: number;
}
interface BoxTreeRayTestResult {
    factor: number;
}
interface BoxTreeRayTestCallback {
    (tree, externalNode, ray: BoxTreeRay, distance, upperBound): BoxTreeRayTestResult;
}
class BoxTreeNode {
    static version: number;
    public escapeNodeOffset: number;
    public externalNode: any;
    public extents: number[];
    constructor(extents, escapeNodeOffset, externalNode);
    public isLeaf(): bool;
    public reset(minX, minY, maxX, maxY, escapeNodeOffset, externalNode?): void;
    public clear(): void;
    static create(extents, escapeNodeOffset, externalNode?): BoxTreeNode;
}
class BoxTree {
    static version: number;
    public nodes: BoxTreeNode[];
    public endNode: number;
    public needsRebuild: bool;
    public needsRebound: bool;
    public numAdds: number;
    public numUpdates: number;
    public numExternalNodes: number;
    public startUpdate: number;
    public endUpdate: number;
    public highQuality: bool;
    public numNodesLeaf: number;
    public arrayConstructor: any;
    constructor(highQuality: bool);
    public add(externalNode, extents): void;
    public remove(externalNode): void;
    public findParent(nodeIndex);
    public update(externalNode, extents): void;
    public needsFinalize(): bool;
    public finalize(): void;
    public rebound(): void;
    public rebuild(): void;
    public sortNodes(nodes): void;
    public sortNodesHighQuality(nodes): void;
    public calculateSAH(buildNodes, startIndex, endIndex): number;
    public nthElement(nodes, first, nth, last, getkey): void;
    public recursiveBuild(buildNodes, startIndex, endIndex, lastNodeIndex): void;
    public getVisibleNodes(planes, visibleNodes): void;
    public getOverlappingNodes(queryExtents, overlappingNodes, startIndex): number;
    public getCircleOverlappingNodes(center, radius, overlappingNodes): void;
    public getOverlappingPairs(overlappingPairs, startIndex): number;
    public getRootNode(): BoxTreeNode;
    public getNodes(): BoxTreeNode[];
    public getEndNodeIndex(): number;
    public clear(): void;
    static rayTest(trees: BoxTree[], ray: BoxTreeRay, callback: BoxTreeRayTestCallback): BoxTreeRayTestResult;
    static create(highQuality): BoxTree;
}
